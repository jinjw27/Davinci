<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë‹¤ë¹ˆì¹˜ ì½”ë“œ (Da Vinci Code) - AI í†µí•© ë²„ì „</title>
    <!-- ONNX Runtime Web CDN -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.3/dist/ort.min.js"></script>
    <style>
        /* ===== ì „ì—­ ìŠ¤íƒ€ì¼ ì„¤ì • ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #ffffff;
            padding: 20px;
        }

        /* ===== í—¤ë” ì˜ì—­ ===== */
        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.2rem;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 0.95rem;
            color: #a0a0a0;
        }

        .ai-badge {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            margin-top: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        /* ===== ë©”ì¸ ì»¨í…Œì´ë„ˆ (2:1 ë ˆì´ì•„ì›ƒ) ===== */
        .main-container {
            display: flex;
            gap: 20px;
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        /* ===== ê²Œì„ ì˜ì—­ (ì™¼ìª½ 2/3) ===== */
        .game-area {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* ===== ê²Œì„ ìƒíƒœ ì •ë³´ íŒ¨ë„ ===== */
        .game-info {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 12px 20px;
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 0.8rem;
            color: #a0a0a0;
            margin-bottom: 3px;
        }

        .info-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4ecca3;
        }

        .info-value.player-turn {
            color: #4ecca3;
        }

        .info-value.ai-turn {
            color: #e94560;
        }

        /* ===== ìº”ë²„ìŠ¤ ìŠ¤íƒ€ì¼ ===== */
        #gameCanvas {
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            background: linear-gradient(180deg, #2d3436 0%, #1e272e 100%);
            width: 100%;
        }

        /* ===== ì»¨íŠ¸ë¡¤ ë²„íŠ¼ ì˜ì—­ ===== */
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 10px 20px;
            font-size: 0.9rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4ecca3, #44bd93);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(78, 204, 163, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #e94560, #c73e54);
            color: #ffffff;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
        }

        .btn-ai {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: #ffffff;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* ===== ì¶”ë¦¬ ì…ë ¥ ì˜ì—­ ===== */
        .guess-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
        }

        .guess-panel.active {
            display: block;
        }

        .guess-input {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .guess-input label {
            font-size: 0.9rem;
        }

        .guess-input select {
            padding: 8px 12px;
            font-size: 0.95rem;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #1a1a2e;
        }

        /* ===== ì‚¬ì´ë“œ íŒ¨ë„ (ì˜¤ë¥¸ìª½ 1/3) ===== */
        .side-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 300px;
        }

        /* ===== AI ë§í’ì„  ì˜ì—­ ===== */
        .ai-bubble-container {
            background: rgba(233, 69, 96, 0.1);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(233, 69, 96, 0.3);
            min-height: 120px;
        }

        .ai-bubble-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .ai-avatar {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .ai-name {
            font-weight: bold;
            color: #667eea;
        }

        .ai-bubble {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border-top-left-radius: 5px;
            padding: 12px 15px;
            position: relative;
            margin-left: 10px;
            animation: fadeIn 0.3s ease;
        }

        .ai-bubble::before {
            content: '';
            position: absolute;
            left: -8px;
            top: 10px;
            border-width: 8px;
            border-style: solid;
            border-color: transparent rgba(255, 255, 255, 0.1) transparent transparent;
        }

        .ai-bubble.thinking {
            color: #74b9ff;
        }

        .ai-bubble.attack {
            color: #e94560;
            font-weight: bold;
        }

        .ai-bubble.success {
            color: #4ecca3;
        }

        .ai-bubble.fail {
            color: #fdcb6e;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== ëª¨ë¸ ìƒíƒœ í‘œì‹œ ===== */
        .model-status {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
            padding: 10px 15px;
            font-size: 0.85rem;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .model-status .status-icon {
            margin-right: 8px;
        }

        .model-status.loading {
            color: #fdcb6e;
        }

        .model-status.ready {
            color: #4ecca3;
        }

        .model-status.error {
            color: #e94560;
        }

        /* ===== ë¡œê·¸ íŒ¨ë„ ===== */
        .log-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            flex: 1;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-header {
            font-weight: bold;
            color: #4ecca3;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .log-entry {
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.success {
            color: #4ecca3;
        }

        .log-entry.fail {
            color: #e94560;
        }

        .log-entry.info {
            color: #74b9ff;
        }

        .log-entry.ai {
            color: #667eea;
        }

        /* ===== ê·œì¹™ ì„¤ëª… ëª¨ë‹¬ ===== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #2d3436, #1e272e);
            border-radius: 20px;
            padding: 25px;
            max-width: 550px;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-content h2 {
            color: #e94560;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }

        .modal-content h3 {
            color: #4ecca3;
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .modal-content p {
            margin-bottom: 10px;
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .modal-content ul {
            margin-left: 20px;
            margin-bottom: 10px;
        }

        .modal-content li {
            margin-bottom: 6px;
            line-height: 1.4;
            font-size: 0.9rem;
        }

        .close-modal {
            margin-top: 15px;
            width: 100%;
        }
    </style>
</head>

<body>
    <!-- í—¤ë” ì˜ì—­ -->
    <div class="header">
        <h1>ğŸ´ ë‹¤ë¹ˆì¹˜ ì½”ë“œ (AI í†µí•©)</h1>
        <p>ìƒëŒ€ë°©ì˜ ìˆ«ìë¥¼ ì¶”ë¦¬í•˜ì—¬ ëª¨ë“  ì¹´ë“œë¥¼ ê³µê°œí•˜ë¼!</p>
        <div class="ai-badge">ğŸ§  Hybrid AI (ONNX + í™•ë¥  ì¶”ë¡ )</div>
    </div>

    <!-- ë©”ì¸ ì»¨í…Œì´ë„ˆ -->
    <div class="main-container">
        <!-- ê²Œì„ ì˜ì—­ (ì™¼ìª½ 2/3) -->
        <div class="game-area">
            <!-- ê²Œì„ ìƒíƒœ ì •ë³´ -->
            <div class="game-info">
                <div class="info-item">
                    <div class="info-label">í˜„ì¬ í„´</div>
                    <div class="info-value" id="currentTurn">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">ë¼ìš´ë“œ</div>
                    <div class="info-value" id="roundNumber">1</div>
                </div>
                <div class="info-item">
                    <div class="info-label">í”Œë ˆì´ì–´ ê³µê°œ</div>
                    <div class="info-value" id="playerRevealed">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">AI ê³µê°œ</div>
                    <div class="info-value" id="aiRevealed">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">ë‚¨ì€ ë±</div>
                    <div class="info-value" id="deckRemaining">-</div>
                </div>
            </div>

            <!-- ìº”ë²„ìŠ¤ -->
            <canvas id="gameCanvas" width="800" height="480"></canvas>

            <!-- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ -->
            <div class="controls">
                <button class="btn btn-primary" id="btnNewGame">ìƒˆ ê²Œì„</button>
                <button class="btn btn-primary" id="btnDrawCard" disabled>ì¹´ë“œ ë½‘ê¸°</button>
                <button class="btn btn-secondary" id="btnRules">ê²Œì„ ê·œì¹™</button>
            </div>

            <!-- ì¶”ë¦¬ íŒ¨ë„ -->
            <div class="guess-panel" id="guessPanel">
                <div class="guess-input">
                    <label>ì¹´ë“œ ìœ„ì¹˜:</label>
                    <select id="cardPosition"></select>
                    <label>ì¶”ë¦¬ ìˆ«ì:</label>
                    <select id="guessNumber">
                        <option value="-1">- (ì¡°ì»¤)</option>
                        <option value="0">0</option>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                        <option value="9">9</option>
                        <option value="10">10</option>
                        <option value="11">11</option>
                    </select>
                    <button class="btn btn-primary" id="btnGuess">ì¶”ë¦¬í•˜ê¸°</button>
                    <button class="btn btn-secondary" id="btnPass">í„´ ë„˜ê¸°ê¸°</button>
                </div>
            </div>
        </div>

        <!-- ì‚¬ì´ë“œ íŒ¨ë„ (ì˜¤ë¥¸ìª½ 1/3) -->
        <div class="side-panel">
            <!-- ëª¨ë¸ ìƒíƒœ -->
            <div class="model-status loading" id="modelStatus">
                <span class="status-icon">â³</span>
                <span id="modelStatusText">ONNX ëª¨ë¸ ë¡œë”© ì¤‘...</span>
            </div>

            <!-- AI ë§í’ì„  -->
            <div class="ai-bubble-container">
                <div class="ai-bubble-header">
                    <div class="ai-avatar">ğŸ§ </div>
                    <span class="ai-name">Neural AI</span>
                </div>
                <div class="ai-bubble" id="aiBubble">
                    ëª¨ë¸ì„ ë¡œë”©í•˜ê³  ìˆìŠµë‹ˆë‹¤...
                </div>
            </div>

            <!-- ê²Œì„ ë¡œê·¸ -->
            <div class="log-panel" id="logPanel">
                <div class="log-header">ğŸ“‹ ê²Œì„ ë¡œê·¸</div>
            </div>
        </div>
    </div>

    <!-- ê·œì¹™ ëª¨ë‹¬ -->
    <div class="modal" id="rulesModal">
        <div class="modal-content">
            <h2>ğŸ´ ë‹¤ë¹ˆì¹˜ ì½”ë“œ ê²Œì„ ê·œì¹™</h2>
            <p><strong>ê²Œì„ ëª©í‘œ:</strong> ìƒëŒ€ë°©ì˜ ëª¨ë“  ì¹´ë“œ ìˆ«ìë¥¼ ë§ì¶° ê³µê°œì‹œí‚¤ë©´ ìŠ¹ë¦¬!</p>

            <h3>ì¹´ë“œ êµ¬ì„±</h3>
            <ul>
                <li>0~11ê¹Œì§€ ìˆ«ì ì¹´ë“œ (í‘/ë°± ê° 12ì¥, ì´ 24ì¥)</li>
                <li><strong>ì¡°ì»¤ 2ì¥</strong> (í‘/ë°± ê° 1ì¥) - í‘œì‹œ: "-"</li>
                <li>ê° í”Œë ˆì´ì–´ëŠ” ì‹œì‘ ì‹œ 4ì¥ì”© ë°›ìŒ</li>
            </ul>

            <h3>ì¹´ë“œ ì •ë ¬ ê·œì¹™</h3>
            <ul>
                <li>ìˆ«ìëŠ” ì™¼ìª½â†’ì˜¤ë¥¸ìª½ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬</li>
                <li>ê°™ì€ ìˆ«ì: ê²€ì€ìƒ‰ì´ ì™¼ìª½</li>
                <li><strong>ì¡°ì»¤:</strong> ì•„ë¬´ ìœ„ì¹˜ë‚˜ ê°€ëŠ¥ (ë‹¨, ì¡°ì»¤ë¼ë¦¬ ë¶™ì–´ìˆìœ¼ë©´ í°ìƒ‰ì´ ì˜¤ë¥¸ìª½)</li>
            </ul>

            <h3>ê²Œì„ ì§„í–‰</h3>
            <ul>
                <li><strong>ì¹´ë“œ ë½‘ê¸°:</strong> ë±ì—ì„œ 1ì¥ ë½‘ì•„ íŒ¨ì— ì¶”ê°€</li>
                <li><strong>ì¶”ë¦¬í•˜ê¸°:</strong> ìƒëŒ€ ì¹´ë“œ ì„ íƒ í›„ ìˆ«ì ì¶”ë¦¬</li>
                <li><strong>ì„±ê³µ:</strong> ì¹´ë“œ ê³µê°œ, ì—°ì† ì¶”ë¦¬ ê°€ëŠ¥</li>
                <li><strong>ì‹¤íŒ¨:</strong> ë‚´ ìƒˆ ì¹´ë“œ ê³µê°œ, í„´ ë„˜ê¹€</li>
            </ul>

            <h3>AI íŠ¹ì§•</h3>
            <p>ğŸ§  ì´ AIëŠ” ONNX ì‹ ê²½ë§ì„ ì‚¬ìš©í•˜ì—¬ ì¶”ë¦¬í•©ë‹ˆë‹¤!</p>

            <button class="btn btn-primary close-modal" id="closeRules">ë‹«ê¸°</button>
        </div>
    </div>

    <script>
        // ========================================
        // ë‹¤ë¹ˆì¹˜ ì½”ë“œ ê²Œì„ - ONNX AI ë²„ì „
        // ========================================

        // ===== ê²Œì„ ìƒìˆ˜ =====
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 480;
        const CARD_WIDTH = 55;
        const CARD_HEIGHT = 85;
        const CARD_GAP = 8;
        const JOKER_VALUE = -1;
        const MAX_HAND_SIZE = 13;
        const NUM_NUMBERS = 13;
        const INPUT_SIZE = 65;
        const OUTPUT_SIZE = MAX_HAND_SIZE * NUM_NUMBERS;

        // ===== ONNX ëª¨ë¸ ê´€ë ¨ =====
        let onnxSession = null;
        let modelLoaded = false;

        // ===== í”„ë¡œí† ì½œ í™•ì¸ =====
        window.onload = function () {
            if (window.location.protocol === 'file:') {
                setTimeout(() => {
                    if (!modelLoaded) {
                        alert("âš ï¸ ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨\n\níŒŒì¼ì„ ì§ì ‘ ì—´ë©´ AIê°€ ì‘ë™í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\ní•´ê²° ë°©ë²•:\n1. 'run_game.bat' (ì„œë²„ ëª¨ë“œ) ì‹¤í–‰\n2. 'run_game_direct.bat' (í¬ë¡¬ ì§ì ‘ ì‹¤í–‰) ì‚¬ìš©");
                    }
                }, 2500);
            }
        };

        // ===== AI ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ (í•˜ì´ë¸Œë¦¬ë“œ AI) =====
        const aiMemory = {
            // ì‹¤íŒ¨í•œ ì¶”ë¦¬ ê¸°ë¡ (ê²Œì„ë‹¹ ë¦¬ì…‹)
            failedGuesses: new Set(),  // "position-number" í˜•ì‹

            // ê° ìœ„ì¹˜ë³„ ê°€ëŠ¥í•œ ìˆ«ì ë²”ìœ„ (ë¶„ì„ ê²°ê³¼ ìºì‹±)
            cachedProbabilities: null,

            // ë§ˆì§€ë§‰ ë¶„ì„ ì‹œì ì˜ ìƒíƒœ í•´ì‹œ
            lastStateHash: null,

            // ì„±ê³µí•œ ì¶”ë¦¬ ì—°ì† íšŸìˆ˜
            consecutiveSuccesses: 0,

            // AI ì„¤ì •
            config: {
                onnxWeight: 0.4,      // ONNX ì‹ ë¢°ë„ ê°€ì¤‘ì¹˜
                ruleWeight: 0.6,       // ê·œì¹™ ê¸°ë°˜ ê°€ì¤‘ì¹˜
                aggressiveness: 0.7,   // ì—°ì† ì¶”ë¦¬ ì ê·¹ì„± (0-1)
                minConfidenceForAttack: 0.15  // ìµœì†Œ ê³µê²© ì‹ ë¢°ë„
            }
        };

        // ===== ê²Œì„ ìƒíƒœ ê´€ë¦¬ =====
        const gameState = {
            deck: [],
            playerHand: [],
            aiHand: [],
            currentTurn: 'player',
            phase: 'waiting',
            round: 1,
            drawnCard: null,
            gameOver: false,
            winner: null,
            playerJokerPositions: [],
            aiJokerPositions: []
        };

        // ìº”ë²„ìŠ¤ & ì»¨í…ìŠ¤íŠ¸
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // DOM ìš”ì†Œ
        const btnNewGame = document.getElementById('btnNewGame');
        const btnDrawCard = document.getElementById('btnDrawCard');
        const btnRules = document.getElementById('btnRules');
        const btnGuess = document.getElementById('btnGuess');
        const btnPass = document.getElementById('btnPass');
        const guessPanel = document.getElementById('guessPanel');
        const cardPositionSelect = document.getElementById('cardPosition');
        const guessNumberSelect = document.getElementById('guessNumber');
        const rulesModal = document.getElementById('rulesModal');
        const closeRules = document.getElementById('closeRules');
        const logPanel = document.getElementById('logPanel');
        const aiBubble = document.getElementById('aiBubble');
        const modelStatus = document.getElementById('modelStatus');
        const modelStatusText = document.getElementById('modelStatusText');

        // =========================================================
        // ONNX ëª¨ë¸ ë¡œë“œ
        // =========================================================
        // =========================================================
        // ONNX ëª¨ë¸ ë¡œë“œ
        // =========================================================
        async function loadONNXModel() {
            try {
                modelStatusText.textContent = 'ONNX ëª¨ë¸ ë¡œë”© ì¤‘...';

                // ì„¤ì • ì ìš© (í˜¸í™˜ì„± ë° ì—ëŸ¬ ë°©ì§€)
                ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.3/dist/";
                ort.env.wasm.numThreads = 1;
                ort.env.wasm.simd = false;
                ort.env.wasm.proxy = false; // ë©”ì¸ ìŠ¤ë ˆë“œ ê°•ì œ ì‹¤í–‰

                // ì´ˆê¸°í™” ëŒ€ê¸° (WASM ì¤€ë¹„ - 1ì´ˆ)
                await new Promise(r => setTimeout(r, 1000));

                // ONNX ëª¨ë¸ ë¡œë“œ
                const modelPath = './davinci_ai.onnx';

                // ì„¸ì…˜ ì˜µì…˜ (WebGL ìš°ì„ , ì‹¤íŒ¨ ì‹œ WASM)
                const sessionOptions = {
                    executionProviders: ['webgl', 'wasm', 'cpu'],
                    graphOptimizationLevel: 'disabled' // ìµœì í™” ì—ëŸ¬ ë°©ì§€
                };

                // ëª¨ë¸ ë¡œë“œ: ë°”ì´ë„ˆë¦¬ ë°©ì‹ìœ¼ë¡œ ì§ì ‘ ì½ê¸°
                console.log(`ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì‹œì‘: ${modelPath}`);
                // ìºì‹œ ë°©ì§€ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
                const response = await fetch(`${modelPath}?t=${Date.now()}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const buffer = await response.arrayBuffer();

                if (buffer.byteLength === 0) {
                    throw new Error('ëª¨ë¸ íŒŒì¼ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤ (0 bytes). ì„œë²„ ì¬ì‹œì‘ ë˜ëŠ” ëª¨ë¸ ì¬ìƒì„±ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                }

                // HTML ì‘ë‹µ ì²´í¬
                const firstByte = new Uint8Array(buffer)[0];
                if (firstByte === 60) { // '<'
                    const text = new TextDecoder().decode(buffer.slice(0, 100));
                    throw new Error(`ì„œë²„ê°€ ONNX ëŒ€ì‹  HTMLì„ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤. (ë‚´ìš©: ${text}...)`);
                }

                console.log(`ëª¨ë¸ ë°”ì´ë„ˆë¦¬ ë¡œë“œ ì™„ë£Œ (${buffer.byteLength} bytes)`);
                onnxSession = await ort.InferenceSession.create(buffer, sessionOptions);

                modelLoaded = true;
                modelStatus.className = 'model-status ready';
                modelStatusText.textContent = 'âœ… Neural AI ì¤€ë¹„ ì™„ë£Œ!';
                setAiBubble('ì‹ ê²½ë§ ëª¨ë¸ ë¡œë“œ ì™„ë£Œ! ê²Œì„ì„ ì‹œì‘í•´ì£¼ì„¸ìš”.', 'success');
                addLog('ğŸ§  ONNX ì‹ ê²½ë§ AI ë¡œë“œ ì™„ë£Œ', 'ai');

                console.log('ONNX ëª¨ë¸ ë¡œë“œ ì„±ê³µ');
                console.log('ì…ë ¥:', onnxSession.inputNames);
                console.log('ì¶œë ¥:', onnxSession.outputNames);

            } catch (error) {
                console.error('ONNX ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:', error);

                let errorMsg = 'ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨';
                if (error.message) errorMsg += `: ${error.message}`;

                modelStatus.className = 'model-status error';
                modelStatusText.textContent = 'âš ï¸ ëª¨ë¸ ì˜¤ë¥˜ - ëœë¤ AI ì‚¬ìš©';
                setAiBubble('ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨... ëœë¤ AIë¡œ í”Œë ˆì´í•©ë‹ˆë‹¤.', 'fail');
                addLog(`âš ï¸ ${errorMsg}`, 'fail');
            }
        }

        // =========================================================
        // ê²Œì„ ìƒíƒœ ì¸ì½”ë”© (ONNX ì…ë ¥ìš©)
        // INPUT_SIZE = 65
        // =========================================================
        function encodeGameState() {
            const features = new Float32Array(65); // Hardcoded 65

            // 1. ê³µê°œëœ ì¹´ë“œ ì •ë³´ (26ê°œ)
            const allCards = [...gameState.playerHand, ...gameState.aiHand];
            for (const card of allCards) {
                if (card.revealed) {
                    let idx;
                    if (card.number === JOKER_VALUE) {
                        idx = card.color === 'black' ? 24 : 25;
                    } else {
                        idx = card.number * 2 + (card.color === 'white' ? 1 : 0);
                    }
                    if (idx >= 0 && idx < 26) {
                        features[idx] = 1.0;
                    }
                }
            }

            // 2. AI íŒ¨ ì •ë³´ (13ê°œ)
            const offset1 = 26;
            for (let i = 0; i < gameState.aiHand.length && i < MAX_HAND_SIZE; i++) {
                const card = gameState.aiHand[i];
                features[offset1 + i] = (card.number + 1) / 13.0; // ì •ê·œí™”
            }

            // 3. í”Œë ˆì´ì–´ íŒ¨ ì •ë³´ (13ê°œ)
            const offset2 = 39;
            for (let i = 0; i < gameState.playerHand.length && i < MAX_HAND_SIZE; i++) {
                if (!gameState.playerHand[i].revealed) {
                    features[offset2 + i] = 1.0;
                }
            }

            // 4. ê°€ëŠ¥í•œ ìˆ«ì ì •ë³´ (13ê°œ)
            const offset3 = 52;
            const revealedNums = allCards.filter(c => c.revealed).map(c => c.number);

            // ì¡°ì»¤
            if (revealedNums.filter(n => n === JOKER_VALUE).length < 2) features[offset3] = 1.0;

            // ìˆ«ì 0-11
            for (let i = 0; i <= 11; i++) {
                if (revealedNums.filter(n => n === i).length < 2) features[offset3 + i + 1] = 1.0;
            }

            return features;
        }

        // =========================================================
        // ONNX ëª¨ë¸ ì¶”ë¡ 
        // =========================================================
        async function predictWithONNX() {
            if (!modelLoaded || !onnxSession) {
                return null;
            }

            try {
                const inputData = encodeGameState();
                // Tensor ìƒì„±: [1, 65]
                const tensor = new ort.Tensor('float32', inputData, [1, 65]);

                const feeds = {};
                feeds[onnxSession.inputNames[0]] = tensor;

                const results = await onnxSession.run(feeds);
                const output = results[onnxSession.outputNames[0]];

                return Array.from(output.data);
            } catch (error) {
                console.error('ONNX ì¶”ë¡  ì˜¤ë¥˜:', error);
                return null;
            }
        }



        // =========================================================
        // í•˜ì´ë¸Œë¦¬ë“œ AI: í™•ë¥  ì¶”ë¡  ì—”ì§„
        // =========================================================

        /**
         * í”Œë ˆì´ì–´ íŒ¨ ë¶„ì„ - ê° ë¹„ê³µê°œ ì¹´ë“œì˜ ê°€ëŠ¥í•œ ìˆ«ì ë²”ìœ„ ê³„ì‚°
         * ì •ë ¬ ê·œì¹™: ì™¼ìª½ < ì˜¤ë¥¸ìª½, ê°™ì€ ìˆ«ìë©´ í‘ìƒ‰ì´ ì™¼ìª½
         */
        function analyzePlayerHand() {
            const hand = gameState.playerHand;
            const revealedNumbers = getRevealedNumbers();
            const analysis = [];

            // ê³µê°œëœ ì¹´ë“œë“¤ì˜ ìˆ«ìì™€ ìœ„ì¹˜ íŒŒì•…
            const revealedPositions = [];
            hand.forEach((card, idx) => {
                if (card.revealed) {
                    revealedPositions.push({
                        index: idx,
                        number: card.number,
                        color: card.color,
                        sortValue: card.getSortValue()
                    });
                }
            });

            // ê° ë¹„ê³µê°œ ì¹´ë“œ ë¶„ì„
            hand.forEach((card, idx) => {
                if (card.revealed) {
                    analysis.push({ index: idx, possibleNumbers: [], isRevealed: true });
                    return;
                }

                // ê¸°ë³¸: ëª¨ë“  ìˆ«ì ê°€ëŠ¥ (-1 ~ 11)
                let possibleNumbers = [];

                // ì¡°ì»¤ ê°€ëŠ¥ ì—¬ë¶€
                const jokerCount = revealedNumbers.filter(n => n === JOKER_VALUE).length;
                if (jokerCount < 2) {
                    possibleNumbers.push(JOKER_VALUE);
                }

                // ì¼ë°˜ ìˆ«ì (0-11)
                for (let n = 0; n <= 11; n++) {
                    const count = revealedNumbers.filter(x => x === n).length;
                    if (count < 2) {
                        possibleNumbers.push(n);
                    }
                }

                // ì •ë ¬ ê·œì¹™ìœ¼ë¡œ ë²”ìœ„ ì¶•ì†Œ
                let minBound = -Infinity;
                let maxBound = Infinity;

                // ì™¼ìª½ì— ê³µê°œëœ ì¹´ë“œê°€ ìˆìœ¼ë©´ ê·¸ë³´ë‹¤ ì»¤ì•¼ í•¨
                for (const revealed of revealedPositions) {
                    if (revealed.index < idx) {
                        // ì™¼ìª½ ì¹´ë“œë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì•„ì•¼ í•¨
                        if (revealed.number !== JOKER_VALUE) {
                            minBound = Math.max(minBound, revealed.number);
                        }
                    }
                    if (revealed.index > idx) {
                        // ì˜¤ë¥¸ìª½ ì¹´ë“œë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì•„ì•¼ í•¨
                        if (revealed.number !== JOKER_VALUE) {
                            maxBound = Math.min(maxBound, revealed.number);
                        }
                    }
                }

                // ë²”ìœ„ ì ìš© (ì¡°ì»¤ëŠ” ì˜ˆì™¸)
                possibleNumbers = possibleNumbers.filter(n => {
                    if (n === JOKER_VALUE) return true;  // ì¡°ì»¤ëŠ” ì–´ë””ë“  ê°€ëŠ¥
                    return n >= minBound && n <= maxBound;
                });

                // ì‹¤íŒ¨í•œ ì¶”ë¦¬ ì œì™¸
                possibleNumbers = possibleNumbers.filter(n => {
                    const key = `${idx}-${n}`;
                    return !aiMemory.failedGuesses.has(key);
                });

                analysis.push({
                    index: idx,
                    possibleNumbers: possibleNumbers,
                    isRevealed: false,
                    minBound: minBound,
                    maxBound: maxBound,
                    probability: possibleNumbers.length > 0 ? 1 / possibleNumbers.length : 0
                });
            });

            return analysis;
        }

        /**
         * í•˜ì´ë¸Œë¦¬ë“œ ìŠ¤ì½”ì–´ ê³„ì‚°
         * ONNX ì˜ˆì¸¡ê³¼ ê·œì¹™ ê¸°ë°˜ í™•ë¥ ì„ ê²°í•©
         */
        function calculateHybridScores(onnxPredictions, analysis) {
            const scores = [];
            const { onnxWeight, ruleWeight } = aiMemory.config;

            for (const item of analysis) {
                if (item.isRevealed || item.possibleNumbers.length === 0) continue;

                for (const num of item.possibleNumbers) {
                    const numIdx = num + 1;  // -1 -> 0, 0 -> 1, ...
                    const outputIdx = item.index * NUM_NUMBERS + numIdx;

                    // ONNX ì ìˆ˜ (ì—†ìœ¼ë©´ 0)
                    let onnxScore = 0;
                    if (onnxPredictions && outputIdx < onnxPredictions.length) {
                        onnxScore = Math.max(0, onnxPredictions[outputIdx]);
                    }

                    // ê·œì¹™ ê¸°ë°˜ ì ìˆ˜ (ê°€ëŠ¥í•œ ìˆ«ì ìˆ˜ ì—­ìˆ˜)
                    const ruleScore = item.probability;

                    // í•˜ì´ë¸Œë¦¬ë“œ ì ìˆ˜
                    const hybridScore = (onnxScore * onnxWeight) + (ruleScore * ruleWeight);

                    scores.push({
                        position: item.index,
                        number: num,
                        onnxScore: onnxScore,
                        ruleScore: ruleScore,
                        hybridScore: hybridScore,
                        possibleCount: item.possibleNumbers.length
                    });
                }
            }

            // ì ìˆ˜ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
            scores.sort((a, b) => b.hybridScore - a.hybridScore);

            return scores;
        }

        /**
         * ì—°ì† ì¶”ë¦¬ ì—¬ë¶€ ê²°ì •
         */
        function shouldContinueGuessing(analysis, hiddenCount) {
            const { aggressiveness, minConfidenceForAttack } = aiMemory.config;

            // ë‚¨ì€ ì¹´ë“œê°€ 2ì¥ ì´í•˜ë©´ ë¬´ì¡°ê±´ ê³„ì†
            if (hiddenCount <= 2) return true;

            // í™•ë¥  80% ì´ìƒ ì¹´ë“œê°€ ìˆìœ¼ë©´ ê³„ì†
            const highProbTarget = analysis.find(a =>
                !a.isRevealed && a.probability >= 0.8
            );
            if (highProbTarget) return true;

            // ì—°ì† ì„±ê³µ ì¤‘ì´ë©´ ë” ì ê·¹ì 
            const successBonus = aiMemory.consecutiveSuccesses * 0.1;
            const adjustedAggression = Math.min(0.95, aggressiveness + successBonus);

            return Math.random() < adjustedAggression;
        }

        /**
         * ì‹¤íŒ¨í•œ ì¶”ë¦¬ ê¸°ë¡
         */
        function recordFailedGuess(position, number) {
            const key = `${position}-${number}`;
            aiMemory.failedGuesses.add(key);
            aiMemory.consecutiveSuccesses = 0;
        }

        /**
         * ì„±ê³µí•œ ì¶”ë¦¬ ê¸°ë¡
         */
        function recordSuccessfulGuess() {
            aiMemory.consecutiveSuccesses++;
        }

        /**
         * AI ë©”ëª¨ë¦¬ ë¦¬ì…‹ (ìƒˆ ê²Œì„ ì‹œ)
         */
        function resetAIMemory() {
            aiMemory.failedGuesses.clear();
            aiMemory.cachedProbabilities = null;
            aiMemory.lastStateHash = null;
            aiMemory.consecutiveSuccesses = 0;
        }

        // =========================================================
        // ì¹´ë“œ í´ë˜ìŠ¤
        // =========================================================
        class Card {
            constructor(number, color) {
                this.number = number;
                this.color = color;
                this.revealed = false;
                this.placedSortValue = null;
            }

            isJoker() {
                return this.number === JOKER_VALUE;
            }

            getSortValue() {
                if (this.isJoker() && this.placedSortValue !== null) {
                    return this.placedSortValue;
                }
                return this.number * 2 + (this.color === 'white' ? 1 : 0);
            }

            getDisplayText() {
                return this.isJoker() ? '-' : this.number.toString();
            }
        }

        // =========================================================
        // ë± ì´ˆê¸°í™”
        // =========================================================
        function initializeDeck() {
            const deck = [];
            for (let i = 0; i <= 11; i++) {
                deck.push(new Card(i, 'black'));
                deck.push(new Card(i, 'white'));
            }
            deck.push(new Card(JOKER_VALUE, 'black'));
            deck.push(new Card(JOKER_VALUE, 'white'));
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            const shuffled = [...deck];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function assignJokerPosition(hand, jokerCard) {
            const usedValues = hand.filter(c => !c.isJoker() || c.placedSortValue !== null)
                .map(c => c.getSortValue());
            const possiblePositions = [];
            for (let i = -1; i <= 24; i += 0.5) {
                if (!usedValues.includes(i)) {
                    possiblePositions.push(i);
                }
            }
            const randomPos = possiblePositions[Math.floor(Math.random() * possiblePositions.length)];
            jokerCard.placedSortValue = randomPos;
        }

        function sortHand(hand) {
            hand.sort((a, b) => a.getSortValue() - b.getSortValue());
            for (let i = 0; i < hand.length - 1; i++) {
                const curr = hand[i];
                const next = hand[i + 1];
                if (curr.isJoker() && next.isJoker()) {
                    if (curr.color === 'white' && next.color === 'black') {
                        [hand[i], hand[i + 1]] = [hand[i + 1], hand[i]];
                    }
                }
            }
            return hand;
        }

        // =========================================================
        // ìƒˆ ê²Œì„ ì‹œì‘
        // =========================================================
        function startNewGame() {
            // AI ë©”ëª¨ë¦¬ ë¦¬ì…‹
            resetAIMemory();

            gameState.deck = initializeDeck();
            gameState.playerHand = [];
            gameState.aiHand = [];
            gameState.currentTurn = 'player';
            gameState.phase = 'draw';
            gameState.round = 1;
            gameState.drawnCard = null;
            gameState.gameOver = false;
            gameState.winner = null;

            for (let i = 0; i < 4; i++) {
                const playerCard = gameState.deck.pop();
                const aiCard = gameState.deck.pop();

                if (playerCard.isJoker()) {
                    assignJokerPosition(gameState.playerHand, playerCard);
                }
                if (aiCard.isJoker()) {
                    assignJokerPosition(gameState.aiHand, aiCard);
                }

                gameState.playerHand.push(playerCard);
                gameState.aiHand.push(aiCard);
            }

            gameState.playerHand = sortHand(gameState.playerHand);
            gameState.aiHand = sortHand(gameState.aiHand);

            const header = logPanel.querySelector('.log-header');
            logPanel.innerHTML = '';
            logPanel.appendChild(header);

            addLog('ğŸ® ìƒˆ ê²Œì„ ì‹œì‘!', 'info');
            addLog('ğŸ“Œ ì¹´ë“œë¥¼ ë½‘ì•„ ì¶”ë¦¬ë¥¼ ì‹œì‘í•˜ì„¸ìš”.', 'info');

            const aiType = modelLoaded ? 'í•˜ì´ë¸Œë¦¬ë“œ AI (ì‹ ê²½ë§+í™•ë¥ ì¶”ë¡ )' : 'í™•ë¥  ì¶”ë¡  AI';
            setAiBubble(`ì•ˆë…•í•˜ì„¸ìš”! ${aiType}ì…ë‹ˆë‹¤. ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤.`, 'thinking');
            addLog(`ğŸ§  AI ëª¨ë“œ: ${aiType}`, 'ai');

            updateUI();
            render();
        }

        // =========================================================
        // ì¹´ë“œ ë½‘ê¸°
        // =========================================================
        function drawCard(isPlayer) {
            if (gameState.deck.length === 0) {
                addLog('âš ï¸ ë±ì— ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤!', 'fail');
                return null;
            }

            const card = gameState.deck.pop();
            const hand = isPlayer ? gameState.playerHand : gameState.aiHand;

            if (card.isJoker()) {
                assignJokerPosition(hand, card);
            }

            hand.push(card);

            if (isPlayer) {
                gameState.playerHand = sortHand(gameState.playerHand);
            } else {
                gameState.aiHand = sortHand(gameState.aiHand);
            }

            return card;
        }

        // =========================================================
        // ì¶”ë¦¬ ì‹¤í–‰
        // =========================================================
        function makeGuess(isPlayerGuessing, cardIndex, guessedNumber) {
            const targetHand = isPlayerGuessing ? gameState.aiHand : gameState.playerHand;
            const targetCard = targetHand[cardIndex];

            if (!targetCard || targetCard.revealed) {
                return false;
            }

            const actualNumber = targetCard.number;

            if (actualNumber === guessedNumber) {
                targetCard.revealed = true;
                const target = isPlayerGuessing ? 'AI' : 'í”Œë ˆì´ì–´';
                const displayNum = guessedNumber === JOKER_VALUE ? 'ì¡°ì»¤(-)' : guessedNumber;
                addLog(`âœ… ì¶”ë¦¬ ì„±ê³µ! ${target}ì˜ ${cardIndex + 1}ë²ˆ ì¹´ë“œ: ${displayNum}`, 'success');
                checkWinCondition();
                return true;
            } else {
                if (gameState.drawnCard) {
                    gameState.drawnCard.revealed = true;
                    const drawnDisplay = gameState.drawnCard.isJoker() ? 'ì¡°ì»¤(-)' : gameState.drawnCard.number;
                    addLog(`âŒ ì¶”ë¦¬ ì‹¤íŒ¨! ìƒˆ ì¹´ë“œ ê³µê°œ: ${drawnDisplay}`, 'fail');
                } else {
                    addLog('âŒ ì¶”ë¦¬ ì‹¤íŒ¨!', 'fail');
                }
                return false;
            }
        }

        // =========================================================
        // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸
        // =========================================================
        function checkWinCondition() {
            const playerAllRevealed = gameState.playerHand.every(card => card.revealed);
            const aiAllRevealed = gameState.aiHand.every(card => card.revealed);

            if (aiAllRevealed) {
                gameState.gameOver = true;
                gameState.winner = 'player';
                addLog('ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ìŠ¹ë¦¬!', 'success');
                setAiBubble('ìœ¼ì•…! ì¡ŒìŠµë‹ˆë‹¤... ë‹¤ì‹œ í•œ íŒ í•˜ì‹¤ë˜ìš”?', 'fail');
            } else if (playerAllRevealed) {
                gameState.gameOver = true;
                gameState.winner = 'ai';
                addLog('ğŸ˜¢ AI ìŠ¹ë¦¬!', 'fail');
                setAiBubble('í›„í›„, ì œê°€ ì´ê²¼ë„¤ìš”! ë‹¤ìŒì—” ë” ì˜í•´ë³´ì„¸ìš”~', 'success');
            }

            if (gameState.gameOver) {
                gameState.phase = 'waiting';
                updateUI();
            }
        }

        // =========================================================
        // í„´ êµëŒ€
        // =========================================================
        function switchTurn() {
            gameState.currentTurn = gameState.currentTurn === 'player' ? 'ai' : 'player';
            gameState.phase = 'draw';
            gameState.drawnCard = null;
            gameState.round++;

            const turnName = gameState.currentTurn === 'player' ? 'í”Œë ˆì´ì–´' : 'AI';
            addLog(`ğŸ”„ ${turnName} í„´`, 'info');

            updateUI();

            if (gameState.currentTurn === 'ai' && !gameState.gameOver) {
                setAiBubble('ìŒ... ì œ ì°¨ë¡€êµ°ìš”. ë¶„ì„ ì¤‘...', 'thinking');
                setTimeout(aiTurn, 1200);
            }
        }

        // =========================================================
        // AI í„´ ë¡œì§
        // =========================================================
        function aiTurn() {
            if (gameState.gameOver) return;

            const drawnCard = drawCard(false);
            if (drawnCard) {
                addLog('ğŸ§  AIê°€ ì¹´ë“œë¥¼ ë½‘ì•˜ìŠµë‹ˆë‹¤.', 'ai');
                gameState.drawnCard = drawnCard;
                setAiBubble('ì¹´ë“œë¥¼ ë½‘ì•˜ìŠµë‹ˆë‹¤! íŒ¨í„´ ë¶„ì„ ì¤‘...', 'thinking');
            }

            render();
            setTimeout(() => aiMakeGuess(), 1500);
        }

        // =========================================================
        // AI ì¶”ë¦¬ ë¡œì§ (í•˜ì´ë¸Œë¦¬ë“œ: ONNX + í™•ë¥  ì¶”ë¡ )
        // =========================================================
        async function aiMakeGuess() {
            if (gameState.gameOver) return;

            const hiddenIndices = [];
            gameState.playerHand.forEach((card, idx) => {
                if (!card.revealed) hiddenIndices.push(idx);
            });

            if (hiddenIndices.length === 0) {
                checkWinCondition();
                return;
            }

            // 1. í”Œë ˆì´ì–´ íŒ¨ ë¶„ì„ (ê·œì¹™ ê¸°ë°˜)
            const analysis = analyzePlayerHand();

            // 2. ONNX ëª¨ë¸ ì˜ˆì¸¡
            const onnxPredictions = await predictWithONNX();

            // 3. í•˜ì´ë¸Œë¦¬ë“œ ìŠ¤ì½”ì–´ ê³„ì‚°
            const hybridScores = calculateHybridScores(onnxPredictions, analysis);

            let targetIdx, guessedNumber, confidence;

            if (hybridScores.length > 0) {
                // ìµœê³  ì ìˆ˜ ì„ íƒ
                const best = hybridScores[0];
                targetIdx = best.position;
                guessedNumber = best.number;
                confidence = best.hybridScore;

                // ë¶„ì„ ë¡œê·¸
                const posAnalysis = analysis.find(a => a.index === targetIdx);
                const possibleCount = posAnalysis ? posAnalysis.possibleNumbers.length : '?';

                if (modelLoaded) {
                    addLog(`ğŸ§  í•˜ì´ë¸Œë¦¬ë“œ ë¶„ì„: ${targetIdx + 1}ë²ˆ ìœ„ì¹˜, ê°€ëŠ¥ ìˆ«ì ${possibleCount}ê°œ`, 'ai');
                    addLog(`   ONNX: ${(best.onnxScore * 100).toFixed(1)}% | ê·œì¹™: ${(best.ruleScore * 100).toFixed(1)}%`, 'ai');
                } else {
                    addLog(`ğŸ§  í™•ë¥  ë¶„ì„: ${targetIdx + 1}ë²ˆ ìœ„ì¹˜, ê°€ëŠ¥ ìˆ«ì ${possibleCount}ê°œ`, 'ai');
                }

                // í™•ë¥ ì´ 100%ë©´ íŠ¹ë³„ ë©”ì‹œì§€
                if (possibleCount === 1) {
                    setAiBubble(`${targetIdx + 1}ë²ˆ ì¹´ë“œëŠ” í™•ì‹¤íˆ ì•Œê² ì–´ìš”! ğŸ¯`, 'attack');
                } else if (best.ruleScore >= 0.5) {
                    setAiBubble(`${targetIdx + 1}ë²ˆ ì¹´ë“œ... ë†’ì€ í™•ë¥ ë¡œ ${guessedNumber === JOKER_VALUE ? 'ì¡°ì»¤' : guessedNumber}!`, 'attack');
                } else {
                    setAiBubble(`${targetIdx + 1}ë²ˆ ì¹´ë“œ... ${guessedNumber === JOKER_VALUE ? 'ì¡°ì»¤(-)' : guessedNumber}ì¸ê°€ìš”?`, 'attack');
                }
            } else {
                // í´ë°±: ë¶„ì„ ë¶ˆê°€ ì‹œ ëœë¤ (ê±°ì˜ ë°œìƒ ì•ˆ í•¨)
                addLog('âš ï¸ ë¶„ì„ ë¶ˆê°€ - ëœë¤ ì¶”ë¦¬', 'fail');
                targetIdx = hiddenIndices[Math.floor(Math.random() * hiddenIndices.length)];

                const usedNumbers = getRevealedNumbers();
                const possibleNumbers = [];
                const jokerCount = usedNumbers.filter(n => n === JOKER_VALUE).length;
                if (jokerCount < 2) possibleNumbers.push(JOKER_VALUE);
                for (let i = 0; i <= 11; i++) {
                    const count = usedNumbers.filter(n => n === i).length;
                    if (count < 2) possibleNumbers.push(i);
                }
                guessedNumber = possibleNumbers[Math.floor(Math.random() * possibleNumbers.length)];
                confidence = 0.1;

                setAiBubble(`${targetIdx + 1}ë²ˆ ì¹´ë“œ... ${guessedNumber === JOKER_VALUE ? 'ì¡°ì»¤(-)' : guessedNumber}?`, 'attack');
            }

            const guessDisplay = guessedNumber === JOKER_VALUE ? 'ì¡°ì»¤(-)' : guessedNumber;
            addLog(`ğŸ§  AI ì¶”ë¦¬: ${targetIdx + 1}ë²ˆ â†’ ${guessDisplay}`, 'ai');

            setTimeout(() => {
                const success = makeGuess(false, targetIdx, guessedNumber);
                render();

                if (success && !gameState.gameOver) {
                    // ì„±ê³µ ê¸°ë¡
                    recordSuccessfulGuess();

                    // ìƒˆë¡œìš´ ë¶„ì„ìœ¼ë¡œ ì—°ì† ì¶”ë¦¬ ê²°ì •
                    const newAnalysis = analyzePlayerHand();
                    const newHiddenCount = newAnalysis.filter(a => !a.isRevealed).length;

                    if (newHiddenCount === 0) {
                        checkWinCondition();
                        return;
                    }

                    const continueAttack = shouldContinueGuessing(newAnalysis, newHiddenCount);

                    if (continueAttack) {
                        // í™•ë¥  ë†’ì€ íƒ€ê²Ÿ ìˆëŠ”ì§€ í™•ì¸
                        const highProbTarget = newAnalysis.find(a => !a.isRevealed && a.probability >= 0.5);
                        if (highProbTarget) {
                            setAiBubble(`ë§ì•˜ë‹¤! ğŸ‰ ë‹¤ìŒ íƒ€ê²Ÿë„ ë³´ì´ë„¤ìš”...`, 'success');
                        } else {
                            setAiBubble(`ë§ì•˜ë‹¤! ê³„ì† ê³µê²©í•©ë‹ˆë‹¤...`, 'success');
                        }
                        setTimeout(() => aiMakeGuess(), 1500);
                    } else {
                        setAiBubble('ë§ì•˜ì§€ë§Œ, ì´ë²ˆì—” ì—¬ê¸°ê¹Œì§€. ë‹¹ì‹  ì°¨ë¡€ì…ë‹ˆë‹¤.', 'thinking');
                        switchTurn();
                    }
                } else if (!gameState.gameOver) {
                    // ì‹¤íŒ¨ ê¸°ë¡
                    recordFailedGuess(targetIdx, guessedNumber);

                    setAiBubble('ì•—, í‹€ë ¸ë„¤ìš”... ë‹¤ìŒì—” ë§ì¶œê²Œìš”! ë‹¹ì‹  ì°¨ë¡€ì…ë‹ˆë‹¤.', 'fail');
                    setTimeout(switchTurn, 1000);
                }
            }, 800);
        }

        // =========================================================
        // ê³µê°œëœ ìˆ«ì ëª©ë¡
        // =========================================================
        function getRevealedNumbers() {
            const numbers = [];
            [...gameState.playerHand, ...gameState.aiHand].forEach(card => {
                if (card.revealed) numbers.push(card.number);
            });
            return numbers;
        }

        // =========================================================
        // AI ë§í’ì„  ì„¤ì •
        // =========================================================
        function setAiBubble(text, type = 'thinking') {
            aiBubble.textContent = text;
            aiBubble.className = 'ai-bubble ' + type;
        }

        // =========================================================
        // UI ì—…ë°ì´íŠ¸
        // =========================================================
        function updateUI() {
            const turnDisplay = document.getElementById('currentTurn');
            turnDisplay.textContent = gameState.currentTurn === 'player' ? 'í”Œë ˆì´ì–´' : 'AI';
            turnDisplay.className = 'info-value ' + (gameState.currentTurn === 'player' ? 'player-turn' : 'ai-turn');

            document.getElementById('roundNumber').textContent = gameState.round;
            document.getElementById('playerRevealed').textContent =
                gameState.playerHand.filter(c => c.revealed).length + '/' + gameState.playerHand.length;
            document.getElementById('aiRevealed').textContent =
                gameState.aiHand.filter(c => c.revealed).length + '/' + gameState.aiHand.length;
            document.getElementById('deckRemaining').textContent = gameState.deck.length;

            btnDrawCard.disabled = !(gameState.currentTurn === 'player' && gameState.phase === 'draw' && !gameState.gameOver);

            if (gameState.currentTurn === 'player' && gameState.phase === 'guess' && !gameState.gameOver) {
                guessPanel.classList.add('active');
                updateCardPositionSelect();
            } else {
                guessPanel.classList.remove('active');
            }
        }

        function updateCardPositionSelect() {
            cardPositionSelect.innerHTML = '';
            gameState.aiHand.forEach((card, idx) => {
                if (!card.revealed) {
                    const option = document.createElement('option');
                    option.value = idx;
                    option.textContent = `${idx + 1}ë²ˆ ì¹´ë“œ`;
                    cardPositionSelect.appendChild(option);
                }
            });
        }

        // =========================================================
        // ë¡œê·¸ ì¶”ê°€
        // =========================================================
        function addLog(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
            entry.textContent = `[${time}] ${message}`;

            const header = logPanel.querySelector('.log-header');
            if (header && header.nextSibling) {
                logPanel.insertBefore(entry, header.nextSibling);
            } else {
                logPanel.appendChild(entry);
            }
        }

        // =========================================================
        // ë Œë”ë§
        // =========================================================
        function render() {
            ctx.fillStyle = '#1e272e';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.font = 'bold 14px Segoe UI';
            ctx.textAlign = 'center';

            ctx.fillStyle = '#667eea';
            ctx.fillText('ğŸ§  Neural AI', CANVAS_WIDTH / 2, 25);
            renderHand(gameState.aiHand, 40, 40, false);

            renderDeck();

            ctx.fillStyle = '#4ecca3';
            ctx.fillText('ğŸ‘¤ í”Œë ˆì´ì–´', CANVAS_WIDTH / 2, 305);
            renderHand(gameState.playerHand, 40, 320, true);

            if (gameState.gameOver) {
                renderGameOver();
            }
        }

        function renderHand(hand, startX, startY, showNumbers) {
            const totalWidth = hand.length * (CARD_WIDTH + CARD_GAP) - CARD_GAP;
            const offsetX = (CANVAS_WIDTH - totalWidth) / 2;

            hand.forEach((card, idx) => {
                const x = offsetX + idx * (CARD_WIDTH + CARD_GAP);
                renderCard(card, x, startY, showNumbers);
            });
        }

        function renderCard(card, x, y, showNumber) {
            ctx.save();

            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            if (card.isJoker()) {
                const gradient = ctx.createLinearGradient(x, y, x + CARD_WIDTH, y + CARD_HEIGHT);
                if (card.color === 'black') {
                    gradient.addColorStop(0, '#2d3436');
                    gradient.addColorStop(1, '#636e72');
                } else {
                    gradient.addColorStop(0, '#dfe6e9');
                    gradient.addColorStop(1, '#b2bec3');
                }
                ctx.fillStyle = gradient;
            } else {
                ctx.fillStyle = card.color === 'black' ? '#2d3436' : '#dfe6e9';
            }

            ctx.strokeStyle = card.revealed ? '#e94560' : '#636e72';
            ctx.lineWidth = card.revealed ? 3 : 1;

            roundRect(ctx, x, y, CARD_WIDTH, CARD_HEIGHT, 6);
            ctx.fill();
            ctx.stroke();

            ctx.shadowColor = 'transparent';

            if (showNumber || card.revealed) {
                ctx.fillStyle = card.color === 'black' ? '#ffffff' : '#2d3436';
                ctx.font = card.isJoker() ? 'bold 28px Segoe UI' : 'bold 22px Segoe UI';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(card.getDisplayText(), x + CARD_WIDTH / 2, y + CARD_HEIGHT / 2);

                if (card.isJoker()) {
                    ctx.font = '10px Segoe UI';
                    ctx.fillText('JOKER', x + CARD_WIDTH / 2, y + CARD_HEIGHT - 12);
                }
            } else {
                ctx.fillStyle = '#636e72';
                ctx.font = 'bold 24px Segoe UI';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('?', x + CARD_WIDTH / 2, y + CARD_HEIGHT / 2);
            }

            ctx.fillStyle = card.color === 'black' ? '#000000' : '#ffffff';
            ctx.strokeStyle = '#636e72';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x + CARD_WIDTH - 10, y + 10, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        }

        function renderDeck() {
            const deckX = CANVAS_WIDTH / 2 - CARD_WIDTH / 2;
            const deckY = 175;

            for (let i = 0; i < Math.min(3, gameState.deck.length); i++) {
                ctx.fillStyle = '#34495e';
                ctx.strokeStyle = '#4a6572';
                ctx.lineWidth = 1;
                roundRect(ctx, deckX - i * 2, deckY - i * 2, CARD_WIDTH, CARD_HEIGHT, 6);
                ctx.fill();
                ctx.stroke();
            }

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText(`ğŸƒ ${gameState.deck.length}ì¥`, deckX + CARD_WIDTH / 2, deckY + CARD_HEIGHT + 18);
        }

        function renderGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.fillStyle = gameState.winner === 'player' ? '#4ecca3' : '#e94560';
            ctx.font = 'bold 42px Segoe UI';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const msg = gameState.winner === 'player' ? 'ğŸ‰ ìŠ¹ë¦¬!' : 'ğŸ˜¢ íŒ¨ë°°!';
            ctx.fillText(msg, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);

            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Segoe UI';
            ctx.fillText('ìƒˆ ê²Œì„ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        // ===== ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ =====
        btnNewGame.addEventListener('click', startNewGame);

        btnDrawCard.addEventListener('click', () => {
            if (gameState.phase !== 'draw' || gameState.currentTurn !== 'player') return;

            const card = drawCard(true);
            if (card) {
                gameState.drawnCard = card;
                const cardType = card.isJoker() ? 'ì¡°ì»¤(-)' : `${card.color === 'black' ? 'ê²€ì •' : 'í°ìƒ‰'} ${card.number}`;
                addLog(`ğŸƒ ì¹´ë“œ íšë“: ${cardType}`, 'info');
                gameState.phase = 'guess';
                updateUI();
                render();
            }
        });

        btnGuess.addEventListener('click', () => {
            const cardIdx = parseInt(cardPositionSelect.value);
            const guessedNum = parseInt(guessNumberSelect.value);
            const guessDisplay = guessedNum === JOKER_VALUE ? 'ì¡°ì»¤(-)' : guessedNum;

            addLog(`ğŸ” ì¶”ë¦¬: ${cardIdx + 1}ë²ˆ â†’ ${guessDisplay}`, 'info');

            const success = makeGuess(true, cardIdx, guessedNum);
            render();

            if (success && !gameState.gameOver) {
                updateCardPositionSelect();
                if (cardPositionSelect.options.length === 0) {
                    checkWinCondition();
                }
                setAiBubble('ì•—, ë§ì¶”ì…¨ë„¤ìš”...!', 'fail');
            } else if (!gameState.gameOver) {
                setAiBubble('í•˜í•˜, í‹€ë ¸ë„¤ìš”! ì œ ì°¨ë¡€ì…ë‹ˆë‹¤.', 'success');
                switchTurn();
            }

            updateUI();
        });

        btnPass.addEventListener('click', () => {
            addLog('â­ï¸ í„´ ë„˜ê¹€', 'info');
            setAiBubble('ì¢‹ì•„ìš”, ì œ ì°¨ë¡€êµ°ìš”!', 'thinking');
            switchTurn();
            render();
        });

        btnRules.addEventListener('click', () => rulesModal.classList.add('active'));
        closeRules.addEventListener('click', () => rulesModal.classList.remove('active'));
        rulesModal.addEventListener('click', (e) => {
            if (e.target === rulesModal) rulesModal.classList.remove('active');
        });

        canvas.addEventListener('click', (e) => {
            if (gameState.phase !== 'guess' || gameState.currentTurn !== 'player') return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = CANVAS_WIDTH / rect.width;
            const scaleY = CANVAS_HEIGHT / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;

            if (clickY >= 40 && clickY <= 40 + CARD_HEIGHT) {
                const totalWidth = gameState.aiHand.length * (CARD_WIDTH + CARD_GAP) - CARD_GAP;
                const offsetX = (CANVAS_WIDTH - totalWidth) / 2;

                gameState.aiHand.forEach((card, idx) => {
                    const cardX = offsetX + idx * (CARD_WIDTH + CARD_GAP);
                    if (clickX >= cardX && clickX <= cardX + CARD_WIDTH && !card.revealed) {
                        cardPositionSelect.value = idx;
                    }
                });
            }
        });

        // ===== ì´ˆê¸°í™” =====
        render();
        addLog('ğŸ´ ë‹¤ë¹ˆì¹˜ ì½”ë“œ ONNX AI ë²„ì „ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!', 'info');

        // ONNX ëª¨ë¸ ë¡œë“œ
        loadONNXModel();
    </script>
</body>

</html>